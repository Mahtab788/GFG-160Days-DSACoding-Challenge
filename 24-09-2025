#Design a SpecialQueue data structure that functions like a normal queue but with additional support for retrieving the minimum and maximum element efficiently.
The SpecialQueue must support the following operations:

enqueue(x): Insert an element x at the rear of the queue.
dequeue(): Remove the element from the front of the queue.
getFront(): Return the front element without removing.
getMin(): Return the minimum element in the queue in O(1) time.
getMax(): Return the maximum element in the queue in O(1) time.
There will be a sequence of queries queries[][]. The queries are represented in numeric form:

1 x : Call enqueue(x)
2:  Call dequeue()
3: Call getFront()
4: Call getMin()
5: Call getMax()
The driver code will process the queries, call the corresponding functions, and print the outputs of getFront(), getMin(), getMax() operations.
You only need to implement the above five functions.

Note: It is guaranteed that all the queries are valid.


class SpecialQueue {

    Queue<Integer> q;
    Deque<Integer> minQ;
    Deque<Integer> maxQ;
    
    public SpecialQueue() {
        // Define Data Structures
        q = new LinkedList<>();
        minQ = new LinkedList<>();
        maxQ = new LinkedList<>();
    }

    public void enqueue(int x) {
        // Insert element into the queue
        q.offer(x);
        
        while(!minQ.isEmpty() && minQ.peekLast()>x) minQ.pollLast();
        
        minQ.offerLast(x);
        
        while(!maxQ.isEmpty() && maxQ.peekLast()<x) maxQ.pollLast();
        
        maxQ.offerLast(x);
    }

    public void dequeue() {
        // Remove element from the queue
        if(q.isEmpty()) return;
        
        int rem = q.poll();
        
        if(!minQ.isEmpty() && minQ.peekFirst()==rem)  minQ.pollFirst();
        
        if(!maxQ.isEmpty() && maxQ.peekFirst()==rem)  maxQ.pollFirst();
    }

    public int getFront() {
        // Get front element
        if(q.isEmpty()) return -1;
        return q.peek();
    }

    public int getMin() {
        // Get minimum element
        if(minQ.isEmpty())  return -1;
        return minQ.peekFirst();
    }

    public int getMax() {
        // Get maximum element
        if(maxQ.isEmpty())  return -1;
        return maxQ.peekFirst();
    }
}
